Лекция по основам информатики

Введение в трансляцию программ

Строгие вычисления - аргументы функции полностью вычисляются до того, как эта функция вызывается. Вызовы процедур в Scheme сегда строгие. Строгую стратегию вычислений часто называют call-by-value.

В случае нестрогих (я проебал)

Примеры нестрогих вычислений:

* '(if cond then else)' - вычисляется либо 'then' либо 'else'
* 'and', 'or'

В языке Си ... операции нестрогие

В некотром смысле разновидность call-by-name - макроподстановка:

''Scheme
(define-syntax double
	(syntax-rules ()
	((double x) (+ x x))))

Пример стратегии "call-by-need" - я.п. Хаскель

test xs = head (map (\x -> x*x) xs)

Будет вычисляться квадрат только самого первого элемента списка
...

Примитивы Scheme для обеспечения ленивых вычислений

Это макрос "(delay expr)" и функция "(...)"

(define-synax delay
	(syntax-rules ()
	((delay expr) (lambda () expr))))

(define (force promise)
	(if (car promise)
		(caar promise)
		(begin
			(set-car! (list ((cadr promise))))
			(caar promise))))

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Введение в трансляцию программ
==============================

Компьютер исполняет машинный код - последовательность примитивных операций: сложение двух ячеек памяти, пересылка значения из одной ячейки в другую, обращение к устройству, передача управления на другую инструкцию.

Человеку писать машинный код трудоёмко и муторно. Решение: программист пишет программу на человекочитаемом языке, компьютер её выполняет.

Способы реализации языка программирования: интерпретация и компиляция.

При интерпретации компьютер читает программу на языке программирования и выполняет инструкции.
Плюсы: удобство, переносимость
Минусы: низкое быстродействие, зависимость от интерпретатора.

При компиляции компьютер переводит программу с человеческого языка на машинный. Транслятор - синоним компилятора.
Плюсы: высокое быстродействие, автономность программ.
Минусы: фаза компиляции, зависимость от платформы.

Гибридный подход: компилятор формирует промежуточный более низкоуровневый код, который затем выполняется интерпретатором.

Стадии компиляции:

1. Лексический анализ программы - программа делится на "слова", некоторые небольшие структурные элементы: знаки операций, идентификаторы, литеральные константы (числа, строки, символы и т.д.). На стадии лексического анализа отбрасываются комментарии и символы пустого пространства (пробелы, табуляции, переводы строк).

	**Лексема** - подстрока исходной программы.
	**Токен** - "обработанная" лексема, токен состоит из метки типа, позиции в исходном файле и атрибута (значения лексемы): '('CLOSE-BRACKET (1 1))',
	'('IDENT (2 1) "counter")', '('NUMBER (2 10) 7)'.

2. Синтаксический анализ - принимает последовательность токенов и строит из них синтаксическое дерево. Последовательность токенов плоская, выход синтаксического анализатора иерархичен - отражает структуру программы.

3. Семантический анализ - проверяет допустимость операций, правильность имён переменных, функций и т.д.

4. Генерация промежуточного представления.

5. Оптимизации.

6. Генерация машинного кода.

7. Компоновка. Программа может состоять из отдельно транслируемых файлов, в том числе библиотек - нужно из них собрать единую готовую программу.

Стадии 1-3 - стадии анализа (front end), стадии 4-7 - стадии синтеза (back end).

Стадии интерпретации:

1. Лексический анализ.
2. Синтаксический анализ.
3. Семантический анализ.
4. Исполнение (интерпретация) построенной программы.