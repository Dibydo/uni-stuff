Семинар 16.12.20

*Философия Unix:*

1) Пишите программы, которые делают что-то одно и делают это хорошо.
2) Пишите программы, которые бы работали вместе.
3) Пишите программы, которые бы поддерживали текстовые потоки, поскольку это универсальный интерфейс.

**Дуг Макилрой - изобретатель каналов Unix и один из основателей традиции Unix**

*Процесс* - это экземпляр работающей программы.

Когда мы в Bash пишем команду, запускается новый процесс, а сама оболочка ждет его завершения. Но процесс можно запустить и в фоне:

$ ./program args &

Знак & означает, что процесс запущен в фоне. Список фоновых программ, запущенных в текущем сеансе, можно получить при помощи команды jobs, она выведет пронумерованные процессы. Команда fg переводит фоновый процесс на передний
план. Процесс может быть приостановлен. Постановка текущей выполняемой программы на паузу выполняется комбинацией CTRL+Z. Процесс в этом случае приостанавливается и уходит в фон. Команда fg к приостановленному процессу его
возобновляет и переводит на передний план. Команда bg - возобновляет и отправляет в фон. Для прерывания процесса используется CTRL+C. Процессы в unix-подобных системах идентифицируется по PID - целое число. Для получения списка
запущенных процессов используется команда ps, по умолчанию выврдит список процессов текущего пользователя. Команда ps aux выводит все процессы в системе с выдачей подробных сведений.

Процессам можно посылать сигналы. Для посылки сигналов используется команда kill. Синтаксис:

kill -N pid

где -N - номер сигнала. По умолчанию посылается сигнал SIGTERM. Сигнал SIGTERM - просьба процессу завершиться. Аналогичную роль играет SIGINT, он как раз посылается с клавиатуры комбинацией CTRL+C. Сигнал SIGSTOP посылается как CTRL+Z.

Сигнал SIGKILL - сигнал на безусловное прерывание программы, имеет код 9. Поэтому, чтобы жестко убить процесс, нужно набрать

kill -9 pid 

Если в программе произошла ошибк доступа к памяти, операционная система посылает процессу сигнал SIGSEGV (segmentation violation, segmentation fault, ошибка сегментации).

Процесс может иметь несколько открытых дескрипторов, из которых он иожет читать данные, либо в них писать. Обычно это дескрипторы открытых файлов или сетевых соединений.

Но есть 3 по умолчанию открытых дескриптора, которые соответствуют двум устройствам:

Дескриптор 0 - чтение с клавиатуры.
Дескриптор 1 - вывод на экран.
Дескриптор 2 - вывод на экран.

В языке C тип FILE - обертка над дескриптором ОС, обертки над этими тремя дескрипторами доступны как константы stdin, stdout и stderr.

Оболочка bash может перенаправлять дескрипторы. Для запущенной программы можно связять stdin, stdout, stderr с файлом или каналом.

Перенаправление стандартного ввода

$ ./program args... < input.txt

Если исходно программа запрашивала у пользователя ввод с клавиатуры, то теперь она читает файл input.txt.

Перенаправление стандартного вывода:

$ ./progam args... > output.txt

На экран ничего не выводится, а то, что программа печатает на экран, на самом деле пишется в файл output.txt. Если до запуска программы файл output.txt существовал, то он перезапишется. Если использовать знак >>, то запись будет осуществляться в конец файла.

Пример:

$ echo hello >> hello.txt
$ echo world >> hello.txt

Перенаправление стандартного потока ошибок:

$ ./program args... 2> errors.txt

Программа может выводить на stdout полезные данные, а на stderr ошибки. Тогда, если stdout перенаправлен и возникнет что-то, о чем нужно уведомить пользователя, (а) сообщение об оштбке пользователь увидит, (б) сообщения об ошибках не перепутаются с полезными данными.

Пример. Программа cat, предназначенная для конкатенации файлов, получает в командной строке имена файлов и их содержимое последовательно пишет на stdout. Перенаправив stdout, мы получим файл с конкатенцией содержимого исходных файлов:

$ cat header.txt body.txt footer.txt > document.txt

Несколько программ можно объединять в конвейер:

$ prog1 args... | prog2 args... | prog3 args

В этом случае stdout каждой из программ будет связан со стандартным вводом (stdin) следующей программы.

Задача: найти в файлах с расширением .с все строки, содержащие #include и вывести их в алфавитном порядке и без повторяющихся строк:

$ cat *.c | grep "#include" | sort | uniq

Многие утилиты в unix-подобных ОС или принимают список файлов в качестве аргументов, или, если файлов не указано, читают стандартный ввод.

Написание скриптов
------------------

Исполнимые файлы в UNIX-подобных ОС отличаются от обычных флагом исполнимости. У каждого файла есть 3 набора флагов rwxrwxrwx, r - доступ на чтение, w - доступ на запись, x - доступ на исполнение. Первая группа - права владельца файла, вторая - права группы пользователей, владеющих файлом, третья - права для всех остальных.

Права доступа типичного файла: rw-r--r--, т.е. владелец может в файл писать, все остальные - только читать.

Права доступа: --x--x--x - файл нельзя прочитать, но можно запустить.

Установка и сброс атрибутов выполняется командой chmod:

chmod +x prog        # добавить флаг исполнимости
chmod +w file.dat    # разрешить запись
chmod -w file.dat    # запретить запись
chmod go-r file.dat  # запретить чтение (r) группе (g) и всеим остальным (o)

Исполнимые файлы могут быть либо двоичными в формате исполнимых файлов ОС (ELF для Линукса, формат Mach-O для macOS), либо скриптами. Скрипты должны начинаться со строки с указанием интерпретатора(shebang).

#!/путь/до/интерпретатора

Для Bash это

#!/bin/bash

или

#!/bin/sh

Если shebang не указан, то на Линуксе по умолчанию вызывается '/bin/sh'.

В сценарии последовательно записыватся команды Bash. Среди них могут быть как вызовы программ, так и встроенные команды включая операторы.

Процессы при завершении устанавливают код возврата. В языке Си кодом возврата является возвращаемое значение main.

с++
int main()
{
	return 100;
}

По соглашению, успешное завершение работы соответствует коду 0, неуспешное - ненулевому числу, причем разные значения - разные ошибки.

Несколько команд можно обьединять знаками (, ), &&, ||.

prog1 && prog2

Код возврата будет ненулевым, если обе программы завершились успешно. Если prog1 завершилась неуспешно, то prog2 не запустится.

./gen-source > source.c && gcc source.c

prog1 || prog2

Соответственно, логическое ИЛИ. prog2 вызовется в любом случае.

./get-info > info.txt || rm info.txt

Команды в Bash разделяются или переводом строки, или знаком ;.

Оператор ветвления имеет вид:

if comand args... ; then
	comand
	...
elif comand args... ; then
	comand
	...
else
	comand
	...
fi

Код после then выполняется, если команда в условии завершилась успешно.

grep возвращает успех, если что-то нашлось, иначе - неуспех.

bash
if grep ERROR file.txt > /dev/null; then
	echo Были ошибки
else
	echo Ошибок не было
fi

Встроенные команды true и false они всегда завершаются, соответственно, успешно и неуспешно.

Цикл while

while comand args...; do
	comand
	...
done

Цикл for:

for perem in string...; do
	comand $perem
	...
done

Переменные окружения. В УНИХ(юникс) есть понятие переменных окружения - набора некоторых глобальных переменных, которые хранят некоторые строки.

Например, переменная PATH хранит список стандартных путей, в которых ищутся исполнимые файлы. Типичное содержимое /bin:/usr/bin:/usr/local/bin . HOME - путь к домашнему каталогу пользователя, USER - имя пользователя.

В Bash можно устанавливать переменные среды при помощи синтаксиса

VAR=VALUE

Получить значение переменной можно при помощи $VARNAME или ${VARNAME}.