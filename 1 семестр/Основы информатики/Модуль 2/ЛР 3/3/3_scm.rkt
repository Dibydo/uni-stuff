(define (ref xs index . elem)
  (if (null? elem)
      (define (ref-help xs index) ;нельзя дефайнить после теста, сначала все задефайнить, потом после теста использовать
        (if (null? xs)
            '()
            (if (equal? index 0)
                (car xs)
                (if (not (null? (cdr xs)))
                    (ref-help (cdr xs) (- index 1))
                    (not (null? (cdr xs)))))))


      (define (translate xs)
        (cond ((vector? xs) (vector->list xs))
              ((string? xs) (string->list xs))
              (else xs)))
      (ref-help (translate xs) index)
      (define (get-type xs)
        (cond ((vector? xs) 'vector)
              ((string? xs) 'string)
              (else 'list)))
      (define (ref-insert xs index new)
        (if (eq? index 0)
            (append (append new (list elem)) xs)
            (if (not (null? (cdr xs)))
                (ref-insert (cdr xs) (- index 1) (append new (list (car xs))))
                (not (null? (cdr xs))))))
        (define (translate xs)
          (cond ((vector? xs) (vector->list xs))
                ((string? xs) (string->list xs))
                (else xs)))
        (define (list-of-char? xs status) 
          (if (null? xs)
              status
              (list-of-char? (cdr xs) (and (char? (car xs)) status))))
        (define (re-translate xs type)
          (cond ((eq? type 'vector) (list->vector xs))
                ((eq? type 'string)) 
                (if (list-of-char? xs #t)
                    (list->string xs)
                    (= 1 2)))
          (else xs))
        (let ((buf (ref-insert (translate xs) index '())))
          (if (not buf)
              buf
              (re-translate buf (get-type xs))))


;tests
;(ref '(1 2 3) 1)
;(ref #(1 2 3) 1)
;(ref "123" 1)
;(ref "123" 3)

;(rеf '(1 2 3) 1 0)
;(rеf #(1 2 3) 1 0)
;(rеf #(1 2 3) 1 #\0)
;(rеf "123" 1 #\0)
;(rеf "123" 1 0)
;(rеf "123" 3 #\4)
;(rеf "123" 5 #\4)

