(define (string->fixed+ s)
  (define s+ (string->list s))
  (if (not (null? s+))
      (cons (- (char->integer (car s+)) 48) (string->fixed+  (list->string (cdr (string->list s)))))
      '()))
(define (string->fixed s)
  (define s1 (string->fixed+ s))
  (if (not (null? s1))
      (if (= (car s1) -2)
          (begin
            (let ((z (length (cdr s1))))
              (append (append (cons (car s1) '()) (cdr s1)) (cons z '()))))
          (cons (car s1) (string->fixed  (list->string (cdr (string->list s))))))
      s1))
(define (fixed->string+ l)
  (if (not (null? (cdr l)))
      (if (= (car l) -2)
          (begin
            (let ((z (length (cdr l))))
              (append (append (cons (integer->char (+ (car l) 48)) '()) (fixed->string+ (cdr l))) (cons (integer->char (+ z 48)) '()))))
          (cons (integer->char (+ (car l) 48)) (fixed->string+ (cdr l))))
      '()))
(define (fixed l)
  (string->number (list->string (cons (car (reverse (fixed->string+ l))) '()))))
(define (fixed->string++ l)
  (list->string (fixed->string+ l)))
(define (fixed->string l)
  (list->string (reverse (cdr (reverse (fixed->string+ l))))))
(define (unfixed l)
  (if (not (null? l))
      (if (= (car l) -2)
          (unfixed (cdr l))
          (cons (car l) (unfixed (cdr l))))
      '()))
(define (fixed+ l l1)
  (define (f c l l1 help)
    (cond ((and (null? l) (null? l1) (= help 0)) (append c '(0)))
          ((and (null? l) (null? l1)) (f (cons help c) l l1 0))
          ((null? l) (f (cons (+ help (car l1)) c) l (cdr l1) 0)) 
          ((null? l1) (f (cons (+ help (car l)) c) (cdr l) l1 0))
          ((and (< (car l) 0) (< (car l1) 0)) (f (cons (car l) c) (cdr l) (cdr l1) help))
          ((< (car l) 0) (f (cons (+ help (car l1)) c) l (cdr l1) 0))
          ((< (car l1) 0) (f (cons (+ help (car l)) c) (cdr l) l1 0))
          (else (f (cons (remainder (+ (car l) (car l1) help) 10) c) (cdr l) (cdr l1) (quotient (+ (car l) (car l1) help) 10)))))
  (f '() (cdr (reverse l)) (cdr (reverse l1)) 0))
(define (l-help l)
  (if (not (null? l))
      (if (and (= (car l) 0) (not (= (car (cdr l)) -2)))
          (l-help (cdr l))
          l)
      '()))
(define (fixed- l l1)
  (define (f c l l1 help signed i y)
      (cond ((and (and (not (null? l)) (not (null? l1))) (= y 0) (< (- (car l) (car l1) signed) 0)) (f c l l1 10 1 i 1))
            ((and (null? l) (null? l1) (= signed 0) (= (car c) -2)) (append (append '(0) (l-help c)) '(0))) 
            ((and (null? l) (null? l1) (= signed 0)) (append (l-help c) '(0)))
            ((null? l) (f (cons (- help (car l1) signed) c) l (cdr l1) 0 0 (+ i 1) 0))
            ((and (null? l1) (< (- (car l) signed) 0)) (f (cons (+ (- (car l) signed) 10) c) (cons (- (car (cdr l)) 1) (cdr (cdr l))) l1 0 0 (+ i 1) 0))
            ((null? l1) (f (cons (- (car l) signed) c) (cdr l) l1 0 0 (+ i 1) 0))
            ((and (< (car l) 0) (< (car l1) 0)) (f (cons (car l) c) (cdr l) (cdr l1) help signed i 0))
            ((< (car l) 0) (f (cons (- help (car l1) signed) c) l (cdr l1) 0 0 (+ i 1) 0))
            ((< (car l1) 0) (f (cons (- (car l) signed) c) (cdr l) l1 0 0 (+ i 1) 0))
            ((and (< (- (car l) (car l1) signed) 0) (= signed 1) (> i 0)) (f (cons (remainder (+ (- (- (car l) signed) (car l1)) help) 10) c) (cdr l) (cdr l1) 0 1 (+ i 1) 0))
            ((and (< (- (car l) (car l1) signed) 0) (= signed 1)) (f (cons (remainder (+ (- (car l) (car l1)) help) 10) c) (cdr l) (cdr l1) 0 1 (+ i 1) 0))             
            (else (f (cons (remainder (+ (- (- (car l) signed) (car l1)) help) 10) c) (cdr l) (cdr l1) 0 0 0 0))))
  (f '() (cdr (reverse l)) (cdr (reverse l1)) 0 0 0 0))
(define (l+help l l1)
  (define (f c l l1 help)
    (begin
      (cond ((and (null? l) (null? l1) (= help 0)) c)
            ((and (null? l) (null? l1)) (f (cons help c) l l1 0))
            ((null? l) (f (cons (+ help (car l1)) c) l (cdr l1) 0)) 
            ((null? l1) (f (cons (+ help (car l)) c) (cdr l) l1 0))
            (else (f (cons (remainder (+ (car l) (car l1) help) 10) c) (cdr l) (cdr l1) (quotient (+ (car l) (car l1) help) 10))))))
  (f '() (reverse l) (reverse l1) 0))
(define (l*help l l1)
  (define (iter c l l1 i j)  
        (cond ((> (length l1) (length l)) (iter c (reverse l1) l i j))
              ((not (null? l1)) (iter (cons (l+help (l*help2 (l*help+ l (car l1)) i j) (vector->list (make-vector (length (l*help2 (l*help+ l (car l1)) i j)) 0))) c) l (cdr l1) (+ i 1) (+ j 1)))
              (else c)))
  (iter '() l (reverse l1) 0 0))
(define (l*help+ l r)
  (if (not (null? l))
      (cons (* (car l) r) (l*help+ (cdr l) r))
      '()))
(define (l*help2 l i j)
  (define (new c i j) 
    (cond ((and (> i 0) (> j 0) (new (append c '(0)) (- i 1) (- j 1))))
          ((and (= i 0) (= j 0)) c)))
  (new l i j))
(define (l++ l)
  (define (iter1 sum1 xs)
    (if (not (null? xs))
        (iter1 (l+help sum1 (car xs)) (cdr xs))
        sum1))
  (iter1 '(0) l))
(define (fixed*+ l l1)
  (let ((l (unsigned l))
        (l1 (unsigned l1))
        (help (car l))
        (help1 (car l1)))
  (define (iter r r1 help f)    
      (cond ((and (= f 0) (or (and (= help -3) (= help1 -3)) (and (not (= help -3)) (not (= help1 -3))))) (append (append (append r (cons -2 '())) r1) '(0)))
            ((or (and (= f 0) (= help -3)) (and (= f 0) (= help1 -3))) (append (append (append (cons -3 '()) (append r (cons -2 '()))) r1) '(0)))
            (else (iter (reverse (cdr (reverse r))) (cons (car (reverse r)) r1) help (- f 1)))))
  (iter (l++ (l*help (unfixed (reverse (cdr (reverse l)))) (unfixed (reverse (cdr (reverse l1)))))) '() help (+ (car (reverse l)) (car (reverse l1))))))
(define (fixed* l l1)
  (define (iter r help f)
      (cond ((and (= f 0) (> help 4)) (l+help r '(1 0)))
            ((or (= help -2) (and (= f 0) (< help 5))) r)
            (else (iter (reverse (cdr (reverse r))) (car (cdr (reverse r))) (- f 1)))))
  (iter (fixed*+ l l1) 0 (car (reverse l))))
(define (l-help> l l1)
  (if (and (not (null? l)) (not (null? l1)))
      (begin
        (if (> (length l) (length l1))
            (= 1 1)
            (if (< (length l) (length l1))
                (= 1 2)
                (if (> (car l) (car l1))
                    (= 1 1)
                    (if (= (car l) (car l1))
                        (l-help> (cdr l) (cdr l1))
                        (= 1 2))))))
        (= 1 2)))
(define (l* . args)
  (define (iter sum xs)
    (if (not (null? xs))
        (iter (l++ (l*help sum (car xs))) (cdr xs))
        sum))
  (iter '(1) args))
(define (l++ l)
  (define (iter1 sum1 xs)
    (if (not (null? xs))
        (iter1 (l+help sum1 (car xs)) (cdr xs))
        sum1))
  (iter1 '(0) l))
(define (unfixed-part l)
  (if (not (null? l))
      (if (not (= (car l) -2))
          (cons (car l) (unfixed-part (cdr l)))
          '())
      '()))
(define (fixed-part+ l z)
  (let ((l (reverse l)))
    (if (and (not (null? l)) (not (zero? z)))
        (if (not (= (car l) -2))
            (cons (car l) (fixed-part+ (reverse (cdr l)) (- z 1)))
            '())
        '())))
(define (fixed-part l z)
  (reverse (fixed-part+ l z)))
(define (unfixed l)
  (if (not (null? l))
      (if (= (car l) -2)
          (unfixed (cdr l))
          (cons (car l) (unfixed (cdr l))))
      '()))
(define (unsigned l)
    (if (not (null? l))
      (if (= (car l) -3)
          (unsigned (cdr l))
          (cons (car l) (unsigned (cdr l))))
      '()))
(define (l->s+ l)
  (if (not (null? l))
      (cons (integer->char (+ (car l) 48)) (l->s+ (cdr l)))
      '()))
(define (l->s l)
  (list->string (l->s+ l)))
(define (s->l s)
  (define s+ (string->list s))
  (if (not (null? s+))
      (cons (- (char->integer (car s+)) 48) (s->l  (list->string (cdr (string->list s)))))
      '()))
(define (fixed/ l l1)
  (let ((l (unsigned l))
        (l1 (unsigned l1))
        (help (car l))
        (help1 (car l1)))
    (define c (/ (string->number (l->s (l+help (l* (unfixed (reverse (cdr (reverse l)))) (cons (car (reverse l)) '())) (vector->list (make-vector (+ 2 (car (reverse l))) 0))))) (string->number (l->s (l+help (l* (unfixed (reverse (cdr (reverse l1)))) (cons (car (reverse l1)) '())) (vector->list (make-vector (+ 2 (car (reverse l1))) 0)))))))
    (if (or (and (= help -3) (not (= help1 -3))) (and (= help1 -3) (not (= help -3))))
      (if (< (remainder (truncate (* (expt 10 (+ (car (reverse l)) 1)) c)) 10) 4)
          (append (append (append (cons (- 3) '()) (cons (truncate c) '())) (cons (- 2)  '())) (append (cdr (s->l (number->string (truncate (* (expt 10 (car (reverse l))) c))))) '(0)))
          (append (append (append (cons (- 3) '()) (cons (truncate c) '())) (cons (- 2)  '())) (append (cdr (s->l (number->string (+ 1 (truncate (* (expt 10 (car (reverse l))) c)))))) '(0))))
      (if (equal? (truncate c) 0)
          (if (< (remainder (truncate (* (expt 10 (+ (car (reverse l)) 1)) c)) 10) 4)
              (append (append (cons (truncate c) '()) (cons (- 2)  '())) (append (cdr (s->l (number->string (truncate (* (expt 10 (+ (car (reverse l)) 1)) c))))) '(0)))
              (append (append (cons (truncate c) '()) (cons (- 2)  '())) (append (cdr (s->l (number->string (+ 1 (truncate (* (expt 10 (+ (car (reverse l)) 1)) c)))))) '(0))))
          (if (> (remainder (truncate (* (expt 10 (+ (car (reverse l)) 1)) c)) 10) 4)
              (append (append (cons (truncate c) '()) (cons (- 2)  '())) (append (cdr (s->l (number->string (+ 1 (truncate (* (expt 10 (car (reverse l))) c)))))) '(0)))
              (append (append (cons (truncate c) '()) (cons (- 2)  '())) (append (cdr (s->l (number->string (truncate (* (expt 10 (car (reverse l))) c))))) '(0))))))))  
(define d 0)
(define (fixed-pi+ k) 
  (do ((x 0 (+ x 1)))
      ((> x k)) (set! d (+ d (* (expt 16 (- x)) (+ (/ 4 (+ (* 8 x) 1)) (/ -2 (+ (* 8 x) 4)) (/ -1 (+ (* 8 x) 5)) (/ -1 (+ (* 8 x) 6)))))))
  (s->l (number->string (truncate (* d (expt 10 k))))))
(define (fixed-pi++ k)
  (let* ((t (fixed-pi+ k))
         (c (append (append (cons (car t) '()) '(-2)) (cdr t))))
    (if (> (car (reverse c)) 4)
        (append (l+help (reverse (cdr (reverse c))) '(1)) '(0))
        (append c '(0)))))
(define fixed-pi (fixed-pi++ 31))
(define (without l l1)
  (if (not (null? l))
      (if (equal? (car l) (car l1))
          (without (cdr l) (cdr l1))
          l1)
      l1))
(define (sphere-volume r)
  (define c (/ (/ (/ (string->number (l->s (unfixed (fixed* (fixed* (fixed* (fixed* (fixed/ (string->fixed "4.000000000000000000000000000000") (string->fixed "3.000000000000000000000000000000")) fixed-pi) r) r) r)))) (expt (expt 10 (car (reverse r))) 3)) (expt (expt 10 30) 2)) 10))
  (append (append (append (s->l (number->string (truncate c))) '()) (cons (- 2)  '())) (without (s->l (number->string (truncate c))) (s->l (number->string (truncate (* (expt 10 (car (reverse r))) c))))) '(0)))
