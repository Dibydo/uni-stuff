(define (s->l s)
  (define s+ (string->list s))
  (if (not (null? s+))
      (cons (- (char->integer (car s+)) 48) (s->l  (list->string (cdr (string->list s)))))
      '()))
(define (l->s+ l)
  (if (not (null? l))
      (cons (integer->char (+ (car l) 48)) (l->s+ (cdr l)))
      '()))
(define (l->s l)
  (list->string (l->s+ l)))
(define (l+help l l1)
  (define (f c l l1 help)
    (begin
      (cond ((and (null? l) (null? l1) (= help 0)) c)
            ((and (null? l) (null? l1)) (f (cons help c) l l1 0))
            ((null? l) (f (cons (+ help (car l1)) c) l (cdr l1) 0)) 
            ((null? l1) (f (cons (+ help (car l)) c) (cdr l) l1 0))
            (else (f (cons (remainder (+ (car l) (car l1) help) 10) c) (cdr l) (cdr l1) (quotient (+ (car l) (car l1) help) 10))))))
  (f '() (reverse l) (reverse l1) 0))
(define (l+ . args)
  (define (iter sum xs)
    (if (not (null? xs))
        (iter (l+help sum (car xs)) (cdr xs))
        sum))
  (iter '(0) args))
(define (l-help l l1)
  (define (f c l l1 help signed i)
    (begin
      (if (and (not (null? l)) (not (null? l1)))
          (begin
            (if (< (- (car l) (car l1) signed) 0)
                (begin
                  (set! help 10)
                  (set! signed 1)))))
      (cond ((and (null? l) (null? l1) (= signed 0)) c) 
            ((null? l) (f (cons (- help (car l1) signed) c) l (cdr l1) 0 0 (+ i 1)))
            ((and (null? l1) (< (- (car l) signed) 0)) (f (cons (+ (- (car l) signed) 10) c) (cons (- (car (cdr l)) 1) (cdr (cdr l))) l1 0 0 (+ i 1)))
            ((null? l1) (f (cons (- (car l) signed) c) (cdr l) l1 0 0 (+ i 1)))
            ((and (< (- (car l) (car l1) signed) 0) (= signed 1) (> i 0)) (f (cons (remainder (+ (- (- (car l) signed) (car l1)) help) 10) c) (cdr l) (cdr l1) 0 1 (+ i 1)))
            ((and (< (- (car l) (car l1) signed) 0) (= signed 1)) (f (cons (remainder (+ (- (car l) (car l1)) help) 10) c) (cdr l) (cdr l1) 0 1 (+ i 1)))             
            (else (f (cons (remainder (+ (- (- (car l) signed) (car l1)) help) 10) c) (cdr l) (cdr l1) 0 0 0)))))
  (f '() (reverse l) (reverse l1) 0 0 0))
(define (l- . args)
  (define (iter sum xs)
    (if (not (null? xs))
        (iter (cons (l-help (car sum) (car xs)) '()) (cdr xs))
        (car sum)))
  (iter args (cdr args)))
(define i -1)
(define j -1)
(define help '())
(define t '())
(define (l*help l l1)
  (if (not (null? l1))
      (begin
        (if (> (length l1) (length l))
            (begin
              (set! help l)
              (set! l l1)
              (set! l1 help)))
        (set! l1 (reverse l1))
        (set! i (+ i 1))
        (set! j (+ j 1))
        (cons (l+help (l*help2 (l*help+ l (car l1)) i j) (vector->list (make-vector (length (l*help2 (l*help+ l (car l1)) i j)) 0))) (l*help l (reverse (cdr l1)))))    
      (begin
        (set! i -1)
        (set! j -1)
        '())))
(define (l*help+ l r)
  (if (not (null? l))
      (cons (* (car l) r) (l*help+ (cdr l) r))
      '()))
(define (l*help2 l i j)
  (define (new c i j) 
    (cond ((and (> i 0) (> j 0) (new (append c '(0)) (- i 1) (- j 1))))
          ((and (= i 0) (= j 0)) c)))
  (new l i j))
(define (l* . args)
  (define (iter sum xs)
    (if (not (null? xs))
        (iter (l++ (l*help sum (car xs))) (cdr xs))
        sum))
  (iter '(1) args))
(define (l++ l)
  (define (iter1 sum1 xs)
    (if (not (null? xs))
        (iter1 (l+help sum1 (car xs)) (cdr xs))
        sum1))
  (iter1 '(0) l))
(define (l-help= l l1)
  (if (and (not (null? l)) (not (null? l1)))
      (if (equal? (car l) (car l1))
          (l-help= (cdr l) (cdr l1))
          (= 1 2))
      (= 1 1)))
(define (l= . args)
  (define (iter help xs)
    (if (not (null? xs))
        (iter (l-help= (car args) (car xs)) (cdr xs))
        help))
  (iter '(0) args))
(define (l-quotient-2 l)
  (if (not (null? (cdr l)))
      (if (= (remainder (car l) 2) 1) 
          (cons (quotient (car l) 2) (l-quotient-2 (append (cons (+ (car (cdr l)) 10) '()) (cdr (cdr l)))))
          (cons (quotient (car l) 2) (l-quotient-2 (cdr l))))
      (cons (quotient (car l) 2) '())))
(define (l-quotient-2-help l)
  (if (not (null? l))
      (if (= (car l) 0)
          (l-quotient-2-help (cdr l))
          l)
      '()))
(define (l-help> l l1)
  (if (and (not (null? l)) (not (null? l1)))
      (begin
        (if (> (length l) (length l1))
            (= 1 1)
            (if (< (length l) (length l1))
                (= 1 2)
                (if (> (car l) (car l1))
                    (= 1 1)
                    (if (= (car l) (car l1))
                        (l-help> (cdr l) (cdr l1))
                        (= 1 2))))))
        (= 1 2)))
(define up '())
(define down '(0))
(define center '())
(define z 0)
(define (l-quotient l l1)
  (if (= z 0)
      (begin
        (set! z 1)
        (set! up l)))
  (if (l-help> (l-help up '(1)) down)
      (begin
        (set! center (l-quotient-2-help (l-quotient-2 (l+help up down))))
        (if (l-help> (l* center l1) l)
            (begin
              (set! up center)
              (l-quotient l l1))
            (begin
              (set! down center)
              (l-quotient l l1))))
      down))
(define (l-remainder l l1)
  (define q (l-quotient l l1))
  (l-quotient-2-help (l-help l (l* l1 q))))
(define (l-factorial l)
  (if (not (null? (l-quotient-2-help l)))
      (l-quotient-2-help (l* l (l-factorial (l-help l '(1)))))
      '(1)))
