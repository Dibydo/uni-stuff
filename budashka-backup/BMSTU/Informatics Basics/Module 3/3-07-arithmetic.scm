(define (operator? a)
  (member a '(#\+ #\- #\/ #\* #\^)))

(define (constant? a)
  (and (> (char->integer a) 47)
       (< (char->integer a) 58)))

(define (variable? a)
  (and (> (char->integer a) 96)
       (< (char->integer a) 123)))

(define (paranthesis? a)
  (or (equal? a #\()
      (equal? a #\))))

(define (delimiter? a)
  (or (equal? a #\space)
      (equal? a #\newline)
      (equal? a #\tab)))

(define (return-constant str)
  (define (f a a1)
    (cond ((null? a) a)
          ((constant? (car a)) (f (cdr a) (cdr a1)))
          ((equal? (car a) #\E) (f (cdr a) (cdr a1)))
          ((equal? (car a) #\e) (f (cdr a) (cdr a1)))
          ((and (member (car a) '(#\+ #\-))
                (or (equal? (car a1) #\e)
                    (equal? (car a1) #\E))) (f (cdr a) (cdr a1)))     
          ((equal? (car a) #\.) (f (cdr a) (cdr a1)))
          (else a)))
  (f str (append '(#\() str)))


(define (return-variable str)
  (define (f a)
    (cond ((null? a) a)
          ((variable? (car a)) (return-variable (cdr a)))
          (else a)))
  (f str))


(define (tokenize str)
  (define (f a res)
    (cond ((null? a) (reverse res))
          ((operator? (car a)) (f (cdr a) (cons (string->symbol (string (car a))) res)))
          ((constant? (car a)) (f (return-constant a) (cons (string->number (list->string (substring+ a (car a) (return-constant a)))) res)))
          ((paranthesis? (car a)) (f (cdr a) (cons (string (car a)) res)))
          ((variable? (car a)) (f (return-variable a) (cons (string->symbol (list->string (substring+ a (car a) (return-variable a)))) res)))
          ((delimiter? (car a)) (f (cdr a) res))
          (else #f)))
  (f (string->list str) '()))

(define (substring+ str a b)
  (define (f e r g res i)
    (cond ((null? e) (reverse res)) 
          ((and (equal? (car e) r) (= i 0)) (f (cdr e) r g (cons (car e) '()) 1))
          ((and (equal? e g) (= i 1)) (f '() r g res 1))
          ((not (null? res)) (f (cdr e) r g (cons (car e) res) 1))))
  (f str a b '() 0))


(define (parse lst)
  
  (define ERROR 1)
  
  (define (parse-expr)
    (let q ((answer (parse-term)))
      (cond ((null? lst) answer)
            ((equal? (car lst) '+) (begin (set! lst (cdr lst)) (q (list answer '+ (parse-term)))))
            ((equal? (car lst) '-) (begin (set! lst (cdr lst)) (q (list answer '- (parse-term)))))
            ((and (not (equal? (car lst) ")")) (not (null? lst))) (ERROR #f))
            (else answer))))
  
  (define (parse-term)
    (let w ((answer (parse-factor)))
      (cond ((null? lst) answer)
            ((equal? (car lst) '/) (begin (set! lst (cdr lst)) (w (list answer '/ (parse-factor)))))
            ((equal? (car lst) '*) (begin (set! lst (cdr lst)) (w (list answer '* (parse-factor)))))
            (else answer))))
  
  (define (parse-factor)
    (let ((answer (parse-power)))
      (cond ((null? lst) answer)
            ((equal? (car lst) '^) (begin (set! lst (cdr lst)) (list answer '^ (parse-factor))))
            (else answer))))
  
  (define (parse-power)
    (if (null? lst)
        (ERROR #f)
        (let ((token (car lst)))
          (cond ((number? token) (begin (set! lst (cdr lst)) token))
                ((equal? token "(") (begin (set! lst (cdr lst)) (let ((answer (parse-expr)))
                                                                  (if (and (not (null? lst)) (equal? (car lst) ")"))
                                                                      (begin
                                                                        (set! lst (cdr lst))
                                                                        answer)
                                                                      (ERROR #f)))))
                ((equal? token '-) (begin (set! lst (cdr lst)) (list '- (parse-power))))
                ((member token '(+ * / =)) (ERROR #f))
                ((symbol? token) (begin (set! lst (cdr lst)) token))
                (else (ERROR #f))))))
  
  (call-with-current-continuation
   (lambda (exit) 
     (set! ERROR exit)
     (parse-expr))))

(define (tree->scheme lst)
  (if (and (pair? lst) (= (length lst) 3))
      (let ((x (car lst))
            (op (cadr lst))
            (y (caddr lst)))
        (cond ((equal? op '^) (list 'expt (tree->scheme x) (tree->scheme y)))
              (else (list op (tree->scheme x) (tree->scheme y)))))
      lst))
