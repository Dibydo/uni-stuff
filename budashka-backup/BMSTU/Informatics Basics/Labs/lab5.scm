;1
(define (number10? char)
  (and (> (char->integer char) 47) (< (char->integer char) 58)))

(define (sign? char)
  (or (eq? char #\+) (eq? char #\-)))

(define (separator? char) 
  (or (eq? char #\space) (or (eq? char #\tab) (eq? char #\newline))))
(define (check-frac str)
  (define (parse str)
    (if (and (not (null? str)) (number10? (car str)))
        (parse (cdr str))
        (if (null? str)
            (= 1 1)
            (if (eq? (car str) #\/)
                (parse (cdr str))
                (= 1 2)))))
  (if (eq? (memq #\/ (string->list str)) #f)
      (memq #\/ (string->list str))
      (if (sign? (car (string->list str))) 
          (parse (cdr (string->list str)))
          (parse (string->list str)))))

(define (easy-scan-frac str)
  (if (check-frac str) 
      str
      (= 1 2)))

(define (scan-frac str)
  (define (parse-value str value)
    (if (and (not (null? str)) (number10? (car str)))
        (parse-value (cdr str) (append value (list (- (char->integer (car str)) 48))))
        value))
  (define (fold list value i)
    (if (not (null? list))
        (fold (cdr list) (+ value (* (car list) (expt 10 i))) (+ i 1))
        value))
  (if (eq? (memq #\/ (string->list str)) #f)
      (memq #\/ (string->list str))
      (if (sign? (car (string->list str)))
          (if (eq? (car (string->list str)) #\+) 
              (/ (fold (reverse (parse-value (cdr (string->list str)) '())) 0 0) (fold (reverse (parse-value (cdr (memq #\/ (string->list str))) '())) 0 0))
              (- (/ (fold (reverse (parse-value (cdr (string->list str)) '())) 0 0) (fold (reverse (parse-value (cdr (memq #\/ (string->list str))) '())) 0 0))))
          (/ (fold (reverse (parse-value (string->list str) '())) 0 0) (fold (reverse (parse-value (cdr (memq #\/ (string->list str))) '())) 0 0)))))

(define (scan-many-fracs str)
  (define (parse list)
    (if (null? list)
        '()
        (if (check-frac (car list))
            (cons (scan-frac (car list)) (parse (cdr list)))
            (= 1 2)))) 
  (define (parse_values stack_number stack str)
    (cond ((and (null? str) (null? stack)) (parse stack_number))
          ((null? str) (parse (append stack_number (list (list->string stack)))))
          ((and (separator? (car str)) (not (null? stack))) (parse_values (append stack_number (list (list->string stack))) '() (cdr str)))
          ((separator? (car str)) (parse_values stack_number stack (cdr str)))
          ((or (or (number10? (car str)) (eq? (car str) #\/)) (and (null? stack) (sign? (car str)))) (parse_values stack_number (append stack (list (car str))) (cdr str)))
          (else (= 1 2))))
  (parse_values '() '() (string->list str)))
      
;2

(define (parse vec)
  (if (not (assertions (vector->list vec)))
      (parser (vector->list vec))
      #f))
(define (parser lst)
  (define (f a result)
    (cond ((null? a) (list '() (parse-body lst)))
          ((and (equal? (car a) 'end) (null? (cdr a))) (list (parse-articles (reverse result)) (parse-body (cdr a))))
          ((and (equal? (car a) 'end) (not (equal? (car (cdr a)) 'define))) (list (parse-articles (reverse result)) (parse-body (cdr a))))
          (else (f (cdr a) (cons (car a) result)))))
  (f lst '()))
(define (parse-articles lst)
  (define (f a article result)
    (cond ((null? a) (reverse (cons (parse-article (append article '(end))) result)))
          ((equal? (car a) 'end) (f (cdr a) '() (cons (parse-article (append article '(end))) result)))
          (else (f (cdr a) (append article (list (car a))) result))))
    (f lst '() '()))
(define (parse-article lst)
  (define (f a expr)
    (cond ((equal? (car a) 'end) (list (cadr expr) (parse-body (cddr expr))))
          (else (f (cdr a) (append expr (list (car a)))))))
  (f lst '()))

(define (parse-body lst)
  (define (f a res)
    (cond ((null? a) res)
          ((and (equal? (car a) 'if) (if-inside (cdr a))) (f (skip-if lst '()) (append res (list (list 'if (parse-body (return lst (cdr a) (skip-if lst '()))))))))
          ((equal? (car a) 'if) (f (return-index a) (append res (list (list 'if (parse-body (skip (cdr a))))))))
          ((not (equal? (car a) 'endif)) (f (cdr a) (append res (list (car a)))))
          (else (f (cdr a) res))))
  (f lst '()))

(define (skip-if lst res)
  (cond ((null? lst) res)
        ((equal? (car lst) 'endif) (skip-if (cdr lst) lst))
        (else (skip-if (cdr lst) res))))

(define (return lst a b)
  (define (f a b c d)
    (cond ((equal? (car a) (car c)) (f a b (cdr c) (reverse c)))
          ((and (not (null? d)) (equal? (car b) (car d))) (reverse (cdr d)))
          ((null? d) (f a b (cdr c) d))
          (else f a b (cdr c) (cdr d))))
  (f a b lst '()))

(define (return-index lst)
  (cond ((equal? (car lst) 'endif) (cdr lst))
       (else (return-index (cdr lst)))))

(define (if-inside lst)
  (cond ((equal? (car lst) 'endif) #f)
        ((equal? (car lst) 'if))
        (else (if-inside (cdr lst)))))

(define (skip lst)
  (cond ((equal? (car lst) 'endif) '())
        (else (cons (car lst) (skip (cdr lst))))))

(define (assertions lst)
  (cond ((and (member 'end lst) (not (member 'define lst))))
        ((and (member 'define lst) (not (member 'end lst))))
        ((and (member 'if lst) (not (member 'endif lst))))
       ((and (member 'endif lst) (not (member 'if lst))))
        ((define-asserts lst #f))
        (else #f)))

(define (define-asserts lst b)
  (cond ((null? lst) #f)
        ((and (equal? (car lst) 'define) b))
        ((equal? (car lst) 'define) (define-asserts (cdr lst) (not b)))
        ((equal? (car lst) 'end) (define-asserts (cdr lst) (not b)))
        (else (define-asserts (cdr lst) b))))
