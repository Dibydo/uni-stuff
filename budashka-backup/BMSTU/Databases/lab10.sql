use lab10;
go


-- 1. Исследовать и проиллюстрировать на примерах различные уровни изоляции транзакций 
-- MS SQL Server, устанавливаемые с использованием инструкции SET TRANSACTION ISOLATION LEVEL
-- 2. Накладываемые блокировки исследовать с использованием sys.dm_tran_locks

-- «Грязное» чтение (dirty read) - чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится).
--                               - чтение транзакцией записи, измененной другой транзакцией, при этом эти изменения еще не зафиксированы;

-- «Невоспроизводимое чтение» (non-repeatable read) - при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными.

-- «Фантомное чтение» (phantom read) - при повторном чтении транзакция обнаруживает новые строки, вставленные другой завершенной транзакцией
--									 - при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.



-- 4 уровня изоляции:
-- незавершенное чтение   (read uncommited);
-- завершенное чтение       (read commited);
-- воспроизводимое чтение (repeatable read);
-- сериализуемость           (serializable);




-- 1 уровень изоляции:
-- незавершенное чтение   (read uncommited);

-- Низший (первый) уровень изоляции. Он гарантирует только отсутствие потерянных обновлений. 
-- Если несколько параллельных транзакций пытаются изменять одну и ту же строку таблицы, то в окончательном варианте строка будет иметь значение, определенное всем набором успешно выполненных транзакций.
-- При этом возможно считывание не только логически несогласованных данных, но и данных, изменения которых ещё не зафиксированы.
-- Транзакции, выполняющие только чтение, при данном уровне изоляции никогда не блокируются.

/* BEGIN TRANSACTION;
	SELECT * FROM CardBalance
	UPDATE CardBalance SET balance = balance * 10 WHERE card_id = 3;
	WAITFOR DELAY '00:00:05';

	ROLLBACK;
	
	SELECT * FROM CardBalance;
	SELECT * FROM sys.dm_tran_locks;

    --COMMIT TRANSACTION
go */

-- 2 уровень изоляции:
-- завершенное чтение       (read commited);
-- На этом уровне обеспечивается защита от чернового, «грязного» чтения, тем не менее, в процессе работы одной транзакции другая может быть успешно завершена и сделанные ею изменения зафиксированы. 
-- В итоге первая транзакция будет работать с другим набором данных.

-- Блокирование читаемых и изменяемых данных.
-- Заключается в том, что читающая транзакция блокирует читаемые данные в разделяемом (shared) режиме, в результате чего параллельная транзакция, пытающаяся изменить эти данные, приостанавливается, 
-- а пишущая транзакция блокирует изменяемые данные для читающих транзакций, работающих на уровне read committed или более высоком, до своего завершения, препятствуя, таким образом, «грязному» чтению.

-- Сохранение нескольких версий параллельно изменяемых строк.
-- При каждом изменении строки СУБД создаёт новую версию этой строки, с которой продолжает работать изменившая данные транзакция, в то время как любой другой «читающей» транзакции 
-- возвращается последняя зафиксированная версия. Преимущество такого подхода в том, что он обеспечивает большую скорость, так как предотвращает блокировки. 
-- Кроме того, при параллельном изменении данных несколькими транзакциями может создаться ситуация, когда несколько параллельных транзакций произведут несогласованные изменения одних и тех же данных (поскольку блокировки отсутствуют, ничто не помешает это сделать). 
-- Тогда та транзакция, которая зафиксируется первой, сохранит свои изменения в основной БД, а остальные параллельные транзакции окажется невозможно зафиксировать (так как это приведёт к потере обновления первой транзакции).


/* BEGIN TRANSACTION;
	SELECT * FROM CardBalance;
	UPDATE CardBalance SET balance = balance * 10 WHERE card_id = 3;
	
	SELECT * FROM CardBalance;
	SELECT * FROM sys.dm_tran_locks;

COMMIT TRANSACTION;
go */


-- 3 уровень изоляции:
-- воспроизводимое чтение       (Repeatable read);

-- Уровень, при котором читающая транзакция «не видит» изменения данных, которые были ею ранее прочитаны. 
-- При этом никакая другая транзакция не может изменять данные, читаемые текущей транзакцией, пока та не окончена.
-- Блокировки в разделяющем режиме применяются ко всем данным, считываемым любой инструкцией транзакции, и сохраняются до её завершения. 
-- Это запрещает другим транзакциям изменять строки, которые были считаны незавершённой транзакцией. Однако другие транзакции могут вставлять новые строки, соответствующие условиям поиска инструкций, содержащихся в текущей транзакции. 
-- При повторном запуске инструкции текущей транзакцией будут извлечены новые строки, что приведёт к фантомному чтению.

/* BEGIN TRANSACTION;

INSERT INTO CardBalance (card_id,card_number,card_type,balance) VALUES(5,869983803603635,N'Voyager',CAST($750.00 as money))
SELECT * FROM sys.dm_tran_locks;

COMMIT TRANSACTION;
go */

-- 4 уровень изоляции:
-- сериализуемость        (Serializable);

-- Самый высокий уровень изолированности; 
-- Транзакции полностью изолируются друг от друга, каждая выполняется так, как будто параллельных транзакций не существует. 
-- Только на этом уровне параллельные транзакции не подвержены эффекту «фантомного чтения».

/* BEGIN TRANSACTION;

INSERT INTO CardBalance (card_id,card_number,card_type,balance) VALUES(6,6011658933962846,N'Discover',CAST($1430.00 as money))
SELECT resource_type, resource_subtype, request_mode FROM sys.dm_tran_locks;

COMMIT TRANSACTION;
go */
